This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: *.py, *.sh
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
aider_is_programmable_1.sh
aider_is_programmable_2.py
claude_code_is_programmable_1.sh
claude_code_is_programmable_2.py
claude_code_is_programmable_3.py
reset.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="aider_is_programmable_1.sh">
aider --message "make a hello.js script that prints hello" hello.js
</file>

<file path="aider_is_programmable_2.py">
#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = []
# ///

import subprocess
import os

# Create directory if it doesn't exist
todo_dir = "./cc_todo"
os.makedirs(todo_dir, exist_ok=True)
todo_file = f"{todo_dir}/todo.ts"

# Generate a random branch name
branch_name = f"feature-todo-app"

try:
    # 1. Create and checkout a new branch
    print(f"Creating and checking out new branch: {branch_name}")
    subprocess.run(["git", "checkout", "-b", branch_name], check=True)

    # 2. Run aider directly with the todo task
    print("Running aider to create todo app...")
    aider_cmd = [
        "aider",
        "--no-git",  # We'll handle git ourselves
        todo_file,
        "--message",
        "CREATE ./cc_todo/todo.ts: a zero library CLI todo app with basic CRUD.",
    ]
    subprocess.run(aider_cmd, check=True)

    # 3. Git operations - stage and commit
    print("Staging and committing changes...")
    subprocess.run(["git", "add", "."], check=True)
    subprocess.run(
        ["git", "commit", "-m", "Add TypeScript todo app with CRUD functionality"],
        check=True,
    )

    # 4. Switch back to main branch
    print("Switching back to main branch...")
    subprocess.run(["git", "checkout", "main"], check=True)

    print(f"Task completed. Changes committed to branch: {branch_name}")

except subprocess.CalledProcessError as e:
    print(f"Command failed: {e}")
except Exception as e:
    print(f"Error: {e}")
    # Try to return to main branch if something went wrong
    try:
        subprocess.run(["git", "checkout", "main"], check=True)
    except:
        pass
</file>

<file path="claude_code_is_programmable_1.sh">
claude -p "make a hello.js script that prints hello" --allowedTools "Write" "Edit"
</file>

<file path="claude_code_is_programmable_2.py">
#!/usr/bin/env -S uv run --script

import subprocess

prompt = """

GIT checkout a NEW branch.

CREATE ./cc_todo/todo.ts: a zero library CLI todo app with basic CRUD. 

THEN GIT stage, commit and SWITCH back to main.

"""

command = ["claude", "-p", prompt, "--allowedTools", "Edit", "Bash", "Write"]

process = subprocess.run(command, check=True)

print(f"Claude process exited with output: {process.stdout}")
</file>

<file path="claude_code_is_programmable_3.py">
#!/usr/bin/env -S uv run --script
#
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "python-dotenv",
#   "rich"
# ]
# ///

import os
import sys
import subprocess
import json
from dotenv import load_dotenv
from rich.console import Console
from rich.syntax import Syntax
from rich import print as rprint

# Initialize rich console
console = Console()

# Load environment variables for Notion API
load_dotenv()
NOTION_API_SECRET = os.getenv("NOTION_INTERNAL_INTEGRATION_SECRET")
if not NOTION_API_SECRET:
    console.print(
        "[bold red]ERROR: NOTION_INTERNAL_INTEGRATION_SECRET not found in environment variables.[/bold red]"
    )
    sys.exit(1)

# Check for the page name argument
if len(sys.argv) < 2:
    console.print(
        "[bold red]ERROR: Please provide a Notion page name as an argument.[/bold red]"
    )
    console.print("Usage: uv run claude_code_is_programmable_3.py <notion_page_name>")
    sys.exit(1)

page_name = sys.argv[1]

# Define the allowed tools for Claude
allowed_tools = [
    # Standard Claude Code tools
    "Bash",
    "Edit",
    "View",
    "GlobTool",
    "GrepTool",
    "LSTool",
    "BatchTool",
    "AgentTool",
    "WebFetchTool",
    "Write",
    # Notion API tools
    "mcp__notionApi__API-get-user",
    "mcp__notionApi__API-get-users",
    "mcp__notionApi__API-get-self",
    "mcp__notionApi__API-post-database-query",
    "mcp__notionApi__API-post-search",
    "mcp__notionApi__API-get-block-children",
    "mcp__notionApi__API-patch-block-children",
    "mcp__notionApi__API-retrieve-a-block",
    "mcp__notionApi__API-update-a-block",
    "mcp__notionApi__API-delete-a-block",
    "mcp__notionApi__API-retrieve-a-page",
    "mcp__notionApi__API-patch-page",
    "mcp__notionApi__API-post-page",
    "mcp__notionApi__API-create-a-database",
    "mcp__notionApi__API-update-a-database",
    "mcp__notionApi__API-retrieve-a-database",
    "mcp__notionApi__API-retrieve-a-page-property",
    "mcp__notionApi__API-retrieve-a-comment",
    "mcp__notionApi__API-create-a-comment",
]

# Create the prompt for Claude
prompt = f"""
# Notion Todo Code Generation Agent

## Objective
You are an agent that will:
1. Find and read a Notion page named "{page_name}"
2. Extract all todo items from the page
3. For each incomplete todo, implement the code changes described in the todo
4. Commit the changes with a descriptive message
5. Mark the todo item as complete in Notion
6. Continue to the next todo item

## Process - Follow these steps exactly:

### Step 1: Find the Notion page
- Use the Notion API via the mcp__notionApi__API-post-search tool to search for a page with the name "{page_name}"
- Extract the page ID from the search results

### Step 2: Get page content
- Use the mcp__notionApi__API-retrieve-a-page tool to get the page details
- Use the mcp__notionApi__API-get-block-children tool to get the page blocks
- Look for any to_do blocks, which represent your todo items
- For each to_do block, capture:
  - The block ID
  - The content text
  - Whether it's already checked/completed

### Step 3: Process each todo
For each UNCHECKED todo item:
1. Read and understand the todo description
2. Implement the code changes described:
   - Use GlobTool, GrepTool, View to explore the codebase
   - Use Edit or Replace to modify or create files
   - Use Bash when necessary to run commands
3. Test your implementation if tests are available
4. Stage and commit your changes with a descriptive message:
   ```bash
   git add .
   git commit -m "Descriptive message about what was implemented"
   ```
5. Mark the todo as complete in Notion using the mcp__notionApi__API-update-a-block tool

### Step 4: Wrap up
- Provide a summary of all todos processed and changes made

## Important Notes:
- Skip any todos that are already checked/complete
- Process todos in the order they appear on the page
- Make one commit per todo item
- Ensure each commit message clearly describes what was implemented
- If a todo cannot be completed, note why but don't mark it as complete
- If a todo is already completed, skip it

## Available Notion Tools:
You have access to the standard Claude Code tools like Bash, Edit, Replace, View, etc., as well as the complete set of Notion API tools:
- mcp__notionApi__API-post-search: Use this to find the Notion page by name
- mcp__notionApi__API-get-block-children: Use this to retrieve the todo items from the page
- mcp__notionApi__API-update-a-block: Use this to mark todos as complete
And many other Notion API tools as needed.

Now begin your task by finding the Notion page named "{page_name}" and processing its todos.
"""

# Execute the Claude command with stream-json output format
try:
    console.print(
        f"[bold blue]ü§ñ Starting Claude Code to process todos from Notion page:[/bold blue] [yellow]{page_name}[/yellow]"
    )

    cmd = [
        "claude",
        "-p",
        prompt,
        "--output-format",
        "stream-json",
        "--allowedTools",
    ] + allowed_tools

    # Start the process and read output as it comes
    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        bufsize=1,  # Line buffered
    )

    # Process and display JSON output in real-time
    console.print("\n[bold green]üìä Streaming Claude output:[/bold green]")
    while True:
        line = process.stdout.readline()
        if not line and process.poll() is not None:
            break

        syntax = Syntax(line, "json", theme="monokai", line_numbers=False)
        console.print(syntax)

    # Check for any errors
    stderr = process.stderr.read()
    if stderr:
        console.print(f"[bold red]‚ö†Ô∏è Error output from Claude:[/bold red]\n{stderr}")

    # Get return code
    return_code = process.wait()
    if return_code == 0:
        console.print(f"[bold green]‚úÖ Claude Code completed successfully[/bold green]")
    else:
        console.print(
            f"[bold red]‚ùå Claude Code failed with exit code: {return_code}[/bold red]"
        )
        sys.exit(return_code)

except subprocess.CalledProcessError as e:
    console.print(f"[bold red]‚ùå Error executing Claude Code: {str(e)}[/bold red]")
    sys.exit(1)
except Exception as e:
    console.print(f"[bold red]‚ùå Unexpected error: {str(e)}[/bold red]")
    sys.exit(1)
</file>

<file path="reset.sh">
git branch -D cc_todo
git branch -D feature-todo-app
rm hello.js
rm -rf cc_todo
rm -rf notion-todos
</file>

</files>
